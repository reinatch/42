NAME = libft.a
CC = cc
CFLAGS = -Wall -Werror -Wextra
SRC = libft.c ft_isalpha.c ft_isdigit.c
OBJ = $(SRC:.c=.o)

all: $(NAME)
# r: This option means to replace or add files to the archive. If the file already exists in the archive, it will be replaced with the new file. If it doesn't exist, it will be added to the archive.
# c: This option means to create a new archive file if it doesn't exist. If the file already exists, this option will allow it to be overwritten with the new archive.
# s: This option means to write an index into the archive. This allows for faster searches within the archive and is recommended for larger archives.
# So, when you run ar rcs $(NAME) $(OBJ), the command will create a new archive file named $(NAME) if it doesn't exist, or replace it if it does. It will then add all the object files listed in $(OBJ) to the archive, and write an index for the archive. The resulting archive file will contain all the compiled functions from your library, which can be linked into other C programs.
$(NAME): $(OBJ)
	ar rcs $(NAME) $(OBJ)
# $(CC): This is a variable that holds the name of the C compiler to be used, such as gcc.
# $(CFLAGS): This is a variable that holds a list of compiler flags to be passed to the compiler. This can include things like optimization levels, warning flags, or other custom flags.
# -c: This option tells the compiler to compile the source file, but not link it into an executable. Instead, it will create an object file.
# $<: This is a special variable that holds the name of the first prerequisite in the dependency list. In this case, it refers to the name of the C source file being compiled.
# -o $@: This option tells the compiler to write the output of the compilation to a file with the given name. $@ is a special variable that holds the name of the target file, which in this case is the object file being created.
# So, when you run $(CC) $(CFLAGS) -c $< -o $@, the compiler will compile the C source file named $<, using the compiler flags specified in $(CFLAGS). It will then create an object file named $@ with the compiled code.
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
# rm: This is a command in Unix-like operating systems that is used to remove files.
# -f: This option tells the rm command to force the removal of the files without prompting the user for confirmation.
# $(OBJ): This is a variable that holds a list of the object files that were created during the compilation process.
# So, when you run rm -f $(OBJ), the command will remove all the object files listed in $(OBJ) without prompting for confirmation. This is useful for cleaning up the directory after compilation is complete, or when you want to force a recompilation of all the source files in your project.
clean:
	rm -f $(OBJ)
# clean: This is a target that removes all the object files generated during the compilation process.
# rm -f $(NAME): This command removes the executable file generated by the compilation process.
# So, when you run make fclean, the clean target is executed first, which removes all the object files. Then, the rm -f $(NAME) command is executed, which removes the executable file that was created by the compilation process. This leaves the directory clean of all generated files, as if the project had never been built.
fclean: clean
	rm -f $(NAME)
re: fclean all
